Index: new/arch/arm/mach-aspeed/ast-lpc.c
===================================================================
--- new.orig/arch/arm/mach-aspeed/ast-lpc.c
+++ new/arch/arm/mach-aspeed/ast-lpc.c
@@ -49,10 +49,14 @@
 #define LPCDBUG(fmt, args...)
 #endif
 
-#if 0
-static inline u32 
-ast_lpc_read(u32 reg)
+#define LPC_KCS4_RCV_INTR                       (1 << 1)
+#define LPC_KCS4_EN                                     (1 << 0)
+static struct ast_lpc_data *ast_lpc;
+
+static inline u32
+ast_lpc_read(struct ast_lpc_data *ast_lpc, u32 reg)
 {
+#if 0
 	u32 val;
 		
 	val = readl(ast_lpc_base + reg);
@@ -60,15 +64,19 @@ ast_lpc_read(u32 reg)
 	LPCDBUG("ast_lpc_read : reg = 0x%08x, val = 0x%08x\n", reg, val);
 	
 	return val;
+#else
+	return readl(ast_lpc->reg_base + reg);
+#endif
 }
 
 static inline void
-ast_lpc_write(u32 val, u32 reg) 
+ast_lpc_write(struct ast_lpc_data *ast_lpc, u32 val, u32 reg)
 {
 	LPCDBUG("ast_lpc_write : reg = 0x%08x, val = 0x%08x\n", reg, val);
-	writel(val, ast_lpc_base + reg);
+	writel(val, ast_lpc->reg_base + reg);
 }
 
+#if 0
 /******************************************************************************/
 
 //Suppose you are going to snoop 0x80 ~ 0x87
@@ -310,24 +318,568 @@ extern void ast_snoop_dma_init(struct as
 }
 EXPORT_SYMBOL(ast_snoop_dma_init);
 #endif
+
+extern u32 StrToHex(char *p)
+{
+	int i, sum;
+	int temp, length;
+	char c;
+	sum = 0;
+	length = strlen(p);
+	for( i = 0; i < (length - 1) ; i++ )
+	{
+		c = *p;
+		if( c >= 'a' && c <= 'z') {
+			temp = c - 87;
+			sum += ((temp) << (4*(length - i - 2)));
+		} else if( c >= 'A' && c <= 'Z') {
+			temp = c - 55;
+			sum += ((temp) << (4*(length - i - 2)));
+		} else {
+			temp = c - 48;
+			sum = sum + ((temp) << (4*(length - i - 2)));
+		}
+		p = p + 1;
+	}
+	return sum;
+}
+EXPORT_SYMBOL(StrToHex);
+
+/**************************   IPMI KCS Function  **********************************************************/
+//Set default KCS address KCS0 : CA0/CA4, KCS1 : CA8/CAC, KCS3 : CA2/CA3, KCS4 : CB2/CB3
+struct ast_kcs_data *register_ipmi_kcs_drv(u8 kcs_no)
+{
+
+	switch(kcs_no) {
+		case 0:
+			ast_lpc->ast_kcs[0].kcs_reg = 1;
+			ast_lpc->ast_kcs[0].ast_lpc = ast_lpc;
+			ast_lpc->ast_kcs[0].regspacings = AST_IPMI_KCS0_REGSPACINGS;	//fix
+			ast_lpc->ast_kcs[0].kcs_irq_hander = NULL;
+			ast_lpc->ast_kcs[0].str = ast_lpc->reg_base + AST_LPC_STR1;
+			ast_lpc->ast_kcs[0].idr = ast_lpc->reg_base + AST_LPC_IDR1;
+			ast_lpc->ast_kcs[0].odr = ast_lpc->reg_base + AST_LPC_ODR1;
+			ast_set_ipmi_kcs_addr(ast_lpc, 0, 0xCA0);
+			break;
+		case 1:
+			ast_lpc->ast_kcs[1].kcs_reg = 1;
+			ast_lpc->ast_kcs[1].ast_lpc = ast_lpc;
+			ast_lpc->ast_kcs[1].regspacings = AST_IPMI_KCS1_REGSPACINGS;	//fix
+			ast_lpc->ast_kcs[1].kcs_irq_hander = NULL;
+			ast_lpc->ast_kcs[1].str = ast_lpc->reg_base + AST_LPC_STR2;
+			ast_lpc->ast_kcs[1].idr = ast_lpc->reg_base + AST_LPC_IDR2;
+			ast_lpc->ast_kcs[1].odr = ast_lpc->reg_base + AST_LPC_ODR2;
+			ast_set_ipmi_kcs_addr(ast_lpc, 1, 0xCA8);
+			break;
+		case 2:
+			ast_lpc->ast_kcs[2].kcs_reg = 1;
+			ast_lpc->ast_kcs[2].ast_lpc = ast_lpc;
+			ast_lpc->ast_kcs[2].regspacings = AST_IPMI_KCS2_REGSPACINGS;	//fix
+			ast_lpc->ast_kcs[2].kcs_irq_hander = NULL;
+			ast_lpc->ast_kcs[2].str = ast_lpc->reg_base + AST_LPC_STR3;
+			ast_lpc->ast_kcs[2].idr = ast_lpc->reg_base + AST_LPC_IDR3;
+			ast_lpc->ast_kcs[2].odr = ast_lpc->reg_base + AST_LPC_ODR3;
+			ast_set_ipmi_kcs_addr(ast_lpc, 2, 0xCA2);
+			break;
+		case 3:
+			ast_lpc->ast_kcs[3].kcs_reg = 1;
+			ast_lpc->ast_kcs[3].ast_lpc = ast_lpc;
+			ast_lpc->ast_kcs[3].regspacings = AST_IPMI_KCS3_REGSPACINGS;	//can change any
+			ast_lpc->ast_kcs[3].kcs_irq_hander = NULL;
+			ast_lpc->ast_kcs[3].str = ast_lpc->reg_base + AST_LPC_STR4;
+			ast_lpc->ast_kcs[3].idr = ast_lpc->reg_base + AST_LPC_IDR4;
+			ast_lpc->ast_kcs[3].odr = ast_lpc->reg_base + AST_LPC_ODR4;
+			ast_set_ipmi_kcs_addr(ast_lpc, 3, 0xCB2);
+			break;
+	}
+
+	return &(ast_lpc->ast_kcs[kcs_no]);
+}
+EXPORT_SYMBOL(register_ipmi_kcs_drv);
+
+void request_ipmi_kcs_irq(u8 kcs_no, ast_ipmi_irq handler)
+{
+	ast_lpc->ast_kcs[kcs_no].kcs_irq_hander = handler;
+
+	switch(kcs_no) {
+		case 0:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR2) | LPC_IBFIF1, AST_LPC_HICR2);
+			break;
+		case 1:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR2) | LPC_IBFIF2, AST_LPC_HICR2);
+			break;
+		case 2:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR3) | LPC_IBFIF3, AST_LPC_HICR2);
+			break;
+		case 3:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICRB) | LPC_KCS4_RCV_INTR, AST_LPC_HICRB);
+			break;
+	}
+}
+EXPORT_SYMBOL(request_ipmi_kcs_irq);
+
+u16 ast_get_ipmi_kcs_addr(struct ast_lpc_data *ast_lpc, u8 kcs_ch)
+{
+	u16 tmp = 0;
+	switch(kcs_ch) {
+		case 0:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) & ~LPC_HICS_LADR12AS, AST_LPC_HICR4);
+			tmp = (ast_lpc_read(ast_lpc, AST_LPC_LADR12H) << 8) | ast_lpc_read(ast_lpc, AST_LPC_LADR12L);
+			break;
+		case 1:
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) | LPC_HICS_LADR12AS, AST_LPC_HICR4);
+			tmp = (ast_lpc_read(ast_lpc, AST_LPC_LADR12H) << 8) | ast_lpc_read(ast_lpc, AST_LPC_LADR12L);
+			break;
+		case 2:
+			tmp = (ast_lpc_read(ast_lpc, AST_LPC_LADR3H) << 8) | ast_lpc_read(ast_lpc, AST_LPC_LADR3L);
+			break;
+		case 3:
+			tmp = ast_lpc_read(ast_lpc, AST_LPC_LADR4) & 0xffff;
+			break;
+		default:
+			break;
+	}
+	return tmp;
+}
+EXPORT_SYMBOL(ast_get_ipmi_kcs_addr);
+
+void ast_set_ipmi_kcs_addr(struct ast_lpc_data *ast_lpc, u8 kcs_ch, u16 kcs_addr)
+{
+	printk("ast_set_ipmi_kcs_addr:set ch %d, addr %x \n", kcs_ch, kcs_addr);
+
+	switch(kcs_ch) {
+		case 0:	//0xca0, 0xca4
+			/* channel address select for channel 0  */
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) & ~LPC_HICS_LADR12AS, AST_LPC_HICR4);
+			ast_lpc_write(ast_lpc, kcs_addr >> 8, AST_LPC_LADR12H);
+			ast_lpc_write(ast_lpc, kcs_addr & 0xff, AST_LPC_LADR12L);
+			break;
+		case 1:	//0xca2, 0xca6
+			/* channel address select for channel 1  */
+			ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) | LPC_HICS_LADR12AS, AST_LPC_HICR4);
+			ast_lpc_write(ast_lpc, kcs_addr >> 8, AST_LPC_LADR12H);
+			ast_lpc_write(ast_lpc, kcs_addr & 0xff, AST_LPC_LADR12L);
+			break;
+		case 2:	//0xcb2, 0xcb3
+			ast_lpc_write(ast_lpc, kcs_addr >> 8,AST_LPC_LADR3H);
+			ast_lpc_write(ast_lpc, kcs_addr & 0xff, AST_LPC_LADR3L);
+			break;
+		case 3:	//0xcax~+4 +1
+			ast_lpc_write(ast_lpc, ((kcs_addr + 1) << 16) | kcs_addr, AST_LPC_LADR4);
+			break;
+		case 4:	//bt +1
+
+			break;
+		default:
+			break;
+	}
+}
+EXPORT_SYMBOL(ast_set_ipmi_kcs_addr);
+
+u8 ast_get_ipmi_kcs_en(struct ast_lpc_data *ast_lpc, u8 kcs_ch)
+{
+	u8 tmp = 0;
+	switch(kcs_ch) {
+		case 0:
+			if(ast_lpc_read(ast_lpc, AST_LPC_HICR0) & LPC_LPC1_EN)
+				tmp = 1;
+			else
+				tmp = 0;
+			break;
+		case 1:
+			if(ast_lpc_read(ast_lpc, AST_LPC_HICR0) & LPC_LPC2_EN)
+				tmp = 1;
+			else
+				tmp = 0;
+			break;
+		case 2:	//kcs 3
+			if((ast_lpc_read(ast_lpc, AST_LPC_HICR0) & LPC_LPC3_EN) && (ast_lpc_read(ast_lpc, AST_LPC_HICR4) & LPC_HICS_KCSENBL))
+				tmp = 1;
+			else
+				tmp = 0;
+			break;
+		case 3:	//kcs4
+			if(ast_lpc_read(ast_lpc, AST_LPC_HICRB) & LPC_KCS4_EN)
+				tmp = 1;
+			else
+				tmp = 0;
+			break;
+		default:
+			printk("Error Ch no !!\n");
+			break;
+	}
+
+	return tmp;
+
+}
+EXPORT_SYMBOL(ast_get_ipmi_kcs_en);
+
+void ast_set_ipmi_kcs_en(struct ast_lpc_data *ast_lpc, u8 kcs_ch, u8 enable)
+{
+	if(enable) {
+		switch(kcs_ch) {
+			case 0: //kcs1
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR0) | LPC_LPC1_EN, AST_LPC_HICR0);
+				break;
+			case 1:	//kcs2
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR0) | LPC_LPC2_EN, AST_LPC_HICR0);
+				break;
+			case 2: //kcs3	--> fix 0xca2 / 0xca3
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR0) | LPC_LPC3_EN, AST_LPC_HICR0);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) | LPC_HICS_KCSENBL, AST_LPC_HICR4);
+				break;
+			case 3: //kcs4
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICRB) | LPC_KCS4_EN, AST_LPC_HICRB);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICRB) | LPC_KCS4_RCV_INTR, AST_LPC_HICRB);
+				break;
+		}
+	} else {
+		switch(kcs_ch) {
+			case 0:	//kcs 1
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR0) & ~LPC_LPC1_EN, AST_LPC_HICR0);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR2) & ~LPC_IBFIF1, AST_LPC_HICR2);
+				break;
+			case 1:	//kcs 2
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR0) & ~LPC_LPC2_EN, AST_LPC_HICR0);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR2) & ~LPC_IBFIF2, AST_LPC_HICR2);
+				break;
+			case 2:	//kcs 3
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR4) & ~LPC_HICS_KCSENBL, AST_LPC_HICR4);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICR2) & ~LPC_IBFIF2, AST_LPC_HICR2);
+				break;
+			case 3:	//kcs 4
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICRB) & ~LPC_KCS4_RCV_INTR, AST_LPC_HICRB);
+				ast_lpc_write(ast_lpc, ast_lpc_read(ast_lpc, AST_LPC_HICRB) & ~LPC_KCS4_EN, AST_LPC_HICRB);
+				break;
+		}
+
+	}
+}
+EXPORT_SYMBOL(ast_set_ipmi_kcs_en);
+
 static struct ast_lpc_driver_data *lpc_driver_data;
 
-static int __devinit ast_lpc_probe(struct platform_device *pdev)
+#if 0
+static const struct attribute_group lpc_attribute_group = {
+	.attrs = ast_lpc_attributes
+};
+
+/**************************   LPC  Snoop Sys fs   End **********************************************************/
+static int
+ast_get_route_selio(struct ast_lpc_data *ast_lpc, u8 io_ch, char *sysfsbuf)
+{
+	u8 tmp = 0;
+	switch(io_ch) {
+		case 0:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL5IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: UART0->IO5, 1:UART1->IO5, 2:UART2->IO5, 3:UART3->IO5, 4:UART4->IO5");
+			break;
+		case 1:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL1IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: UART1->IO1, 1:UART2->IO1, 2:UART3->IO1, 3:UART4->IO1, 4:UART0->IO1");
+			break;
+		case 2:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL2IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: UART2->IO2, 1:UART3->IO2, 2:UART4->IO2, 3:UART0->IO2, 4:UART1->IO2");
+			break;
+		case 3:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL3IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: UART3->IO3, 1:UART4->IO3, 2:UART5->IO3, 3:UART1->IO3, 4:UART2->IO3");
+			break;
+		case 4:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL4IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: UART4->IO4, 1:UART0->IO4, 2:UART1->IO4, 3:UART2->IO4, 4:UART3->IO4");
+			break;
+		case 6:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL6IO(ast_lpc_read(ast_lpc, AST_LPC_HICR9)), "0: UART1->IO6, 1:UART2->IO6, 2:UART3->IO6, 3:UART4->IO6, 4:UART0->IO6");
+			break;
+
+		default:
+			printk("Error Ch no !!\n");
+			break;
+	}
+
+	return tmp;
+
+}
+
+static int
+ast_get_route_seldw(struct ast_lpc_data *ast_lpc, u8 io_ch, char *sysfsbuf)
+{
+	u8 tmp = 0;
+	switch(io_ch) {
+		case 0:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL5DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: IO0->UART0, 1:IO1->UART0, 2:IO2->UART0, 3:IO3->UART0, 4:IO4->UART0, 5:UART1->UART0, 6:UART2->UART0, 7:UART3->UART0, 8:UART4->UART0, 9:IO6->UART0");
+			break;
+		case 1:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL1DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: IO1->UART1, 1:IO2->UART1, 2:IO3->UART1, 3:IO4->UART1, 4:UART2->UART1, 5:UART3->UART1, 6:UART4->UART1, 7:IO6->UART1");
+			break;
+		case 2:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL2DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: IO2->UART2, 1:IO3->UART2, 2:IO4->UART2, 3:IO1->UART2, 4:UART3->UART2, 5:UART4->UART2, 6:UART1->UART2, 7:IO6->UART2");
+			break;
+		case 3:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL3DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: IO3->UART3, 1:IO4->UART3, 2:IO1->UART3, 3:IO2->UART3, 4:UART4->UART3, 5:UART1->UART3, 6:UART2->UART3, 7:IO6->UART3");
+			break;
+		case 4:
+			return sprintf(sysfsbuf, "%d - [%s]\n", GET_LPC_SEL4DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA)), "0: IO4->UART4, 1:IO1->UART4, 2:IO2->UART4, 3:IO3->UART4, 4:UART1->UART4, 5:UART2->UART4, 6:UART3->UART4, 7:IO6->UART4");
+			break;
+		default:
+			printk("Error Ch no !!\n");
+			break;
+	}
+
+	return tmp;
+
+}
+
+static void
+ast_set_route_selio(struct ast_lpc_data *ast_lpc, u8 io_ch, u8 value)
+{
+	switch(io_ch) {
+		case 0:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL5IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 1:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL1IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 2:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL2IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 3:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL3IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 4:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL4IO(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 6:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL6IO(ast_lpc_read(ast_lpc, AST_LPC_HICR9), value),
+						AST_LPC_HICR9);
+			break;
+
+		default:
+			printk("Error Ch no !!\n");
+			break;
+	}
+
+}
+
+static void
+ast_set_route_seldw(struct ast_lpc_data *ast_lpc, u8 io_ch, u8 value)
+{
+	switch(io_ch) {
+		case 0:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL5DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 1:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL1DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 2:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL2DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 3:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL3DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+			break;
+		case 4:
+			ast_lpc_write(ast_lpc, SET_LPC_SEL4DW(ast_lpc_read(ast_lpc, AST_LPC_HICRA), value),
+						AST_LPC_HICRA);
+
+			break;
+		default:
+			printk("Error Ch no !!\n");
+			break;
+	}
+}
+
+static ssize_t
+ast_store_route(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_lpc_data *ast_lpc = dev_get_drvdata(dev);
+	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
+
+	input_val = simple_strtoul(sysfsbuf, NULL, 10);
+
+	//sensor_attr->index : ch#
+	//sensor_attr->nr : attr#
+	switch(sensor_attr->nr)
+	{
+		case 0: //selio
+			ast_set_route_selio(ast_lpc, sensor_attr->index, input_val);
+			break;
+		case 1: //seldw
+			ast_set_route_seldw(ast_lpc, sensor_attr->index, input_val);
+			break;
+		default:
+			return -EINVAL;
+			break;
+	}
+
+	return count;
+}
+
+static ssize_t
+ast_show_route(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+
+	struct ast_lpc_data *ast_lpc = dev_get_drvdata(dev);
+	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
+
+	//sensor_attr->index : ch#
+	//sensor_attr->nr : attr#
+	switch(sensor_attr->nr)
+	{
+		case 0: //selio
+			return ast_get_route_selio(ast_lpc, sensor_attr->index, sysfsbuf);
+			break;
+		case 1: //seldw
+			return ast_get_route_seldw(ast_lpc, sensor_attr->index, sysfsbuf);
+			break;
+		default:
+			return -EINVAL;
+			break;
+	}
+	return -EINVAL;
+}
+
+#define sysfs_route_ch(index) \
+static SENSOR_DEVICE_ATTR_2(route##index##_selio, S_IRUGO | S_IWUSR, \
+	ast_show_route, ast_store_route, 0, index); \
+static SENSOR_DEVICE_ATTR_2(route##index##_seldw, S_IRUGO | S_IWUSR, \
+	ast_show_route, ast_store_route, 1, index); \
+\
+static struct attribute *route##index##_attributes[] = { \
+	&sensor_dev_attr_route##index##_selio.dev_attr.attr, \
+	&sensor_dev_attr_route##index##_seldw.dev_attr.attr, \
+	NULL \
+};
+
+sysfs_route_ch(0);
+sysfs_route_ch(1);
+sysfs_route_ch(2);
+sysfs_route_ch(3);
+sysfs_route_ch(4);
+sysfs_route_ch(5);
+sysfs_route_ch(6);
+
+static const struct attribute_group route_attribute_groups[] = {
+	{ .attrs = route0_attributes },
+	{ .attrs = route1_attributes },
+	{ .attrs = route2_attributes },
+	{ .attrs = route3_attributes },
+	{ .attrs = route4_attributes },
+	{ .attrs = route5_attributes },
+	{ .attrs = route6_attributes },
+};
+#endif
+
+static irqreturn_t ast_lpc_isr (int this_irq, void *dev_id)
+{
+	struct ast_lpc_data *ast_lpc = dev_id;
+	LPCDBUG("\n");
+
+#if 0
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR2) & LPC_LRST) {
+		printk("LPC_LRST TODO ~~\n");
+	}
+
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR2) & LPC_SDWN) {
+		printk("LPC_SDWN TODO ~~\n");
+	}
+
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR2) & LPC_ABRT) {
+		printk("LPC_ABRT TODO ~~\n");
+	}
+#endif
+
+	//SNOOP
+#ifdef CONFIG_AST_SNOOP
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR6) & LPC_HICR6_STR_SNP0W) {
+		ast_lpc->ast_snoop[0].fifo[ast_lpc->ast_snoop[0].write_idx] =
+			GET_LPC_SNPD0(ast_lpc_read(ast_lpc, AST_LPC_SNPWDR));
+#if 0
+		printk("Ch0 data %x \n",
+			GET_LPC_SNPD1(ast_lpc_read(ast_lpc, AST_LPC_SNPWDR)));
+		printk("Ch0 data in fifo widx %d : %x \n",
+		ast_lpc->ast_snoop[0].write_idx,
+		ast_lpc->ast_snoop[0].fifo[ast_lpc->ast_snoop[0].write_idx]);
+#endif
+		ast_lpc->ast_snoop[0].snoop_irq_hander(&ast_lpc->ast_snoop[0]);
+		ast_lpc_write(ast_lpc, LPC_HICR6_STR_SNP0W,  AST_LPC_HICR6);
+	}
+
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR6) & LPC_HICR6_STR_SNP1W) {
+		ast_lpc->ast_snoop[1].fifo[ast_lpc->ast_snoop[1].write_idx] =
+			GET_LPC_SNPD1(ast_lpc_read(ast_lpc, AST_LPC_SNPWDR));
+#if 0
+		printk("Ch1 data %x \n",
+			GET_LPC_SNPD1(ast_lpc_read(ast_lpc, AST_LPC_SNPWDR)));
+		printk("Ch1 data in fifo widx %d : %x \n",
+		ast_lpc->ast_snoop[0].write_idx,
+		ast_lpc->ast_snoop[1].fifo[ast_lpc->ast_snoop[1].write_idx]);
+#endif
+		ast_lpc->ast_snoop[1].snoop_irq_hander(&ast_lpc->ast_snoop[1]);
+		ast_lpc_write(ast_lpc, LPC_HICR6_STR_SNP1W,  AST_LPC_HICR6);
+	}
+#endif
+
+#ifdef CONFIG_AST_SNOOP_DMA
+	if(ast_lpc_read(ast_lpc, AST_LPC_PCCR2) & LPC_POST_CODE_STS) {
+    if (ast_lpc->ast_snoop_dma->snoop_irq_hander)
+      ast_lpc->ast_snoop_dma->snoop_irq_hander(ast_lpc->ast_snoop_dma);
+	}
+#endif
+
+//#ifdef CONFIG_AST_IPMI_KCS
+	//kcs 1:
+	if(ast_lpc_read(ast_lpc, AST_LPC_STR1) & LPC_STR_IBF) {
+		ast_lpc->ast_kcs[0].kcs_irq_hander(&ast_lpc->ast_kcs[0]);
+	}
+	//kcs 2
+	if(ast_lpc_read(ast_lpc, AST_LPC_STR2) & LPC_STR_IBF) {
+		ast_lpc->ast_kcs[2].kcs_irq_hander(&ast_lpc->ast_kcs[1]);
+	}
+	//kcs 3
+	if(ast_lpc_read(ast_lpc, AST_LPC_STR3) & LPC_STR_IBF) {
+		ast_lpc->ast_kcs[2].kcs_irq_hander(&ast_lpc->ast_kcs[2]);
+	}
+	//kcs 4
+	if(ast_lpc_read(ast_lpc, AST_LPC_STR4) & LPC_STR_IBF) {
+		ast_lpc->ast_kcs[3].kcs_irq_hander(&ast_lpc->ast_kcs[3]);
+	}
+//#endif
+
+#ifdef CONFIG_AST_IPMI_BT
+	//bt 0
+	if(ast_lpc_read(ast_lpc, AST_LPC_HICR4) & LPC_HICS_BTENBL) {
+		ast_lpc->ast_bt[0].bt_irq_hander(&ast_lpc->ast_bt[0]);
+	}
+	//ibt 1
+	if(ast_lpc_read(ast_lpc, AST_LPC_IBTCR2) & LPC_iBT_H2B_RISING_ISR) {
+		ast_lpc->ast_bt[1].bt_irq_hander(&ast_lpc->ast_bt[1]);
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+static int ast_lpc_probe(struct platform_device *pdev)
 {
 //	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct resource *res;
 	int ret = 0;
-	int i;
+	int i = 0;
 
-	lpc_driver_data = kzalloc(sizeof(struct ast_lpc_driver_data), GFP_KERNEL);
-	if (lpc_driver_data == NULL) {
+	ast_lpc = kzalloc(sizeof(struct ast_lpc_data), GFP_KERNEL);
+	if (ast_lpc == NULL) {
 		dev_err(&pdev->dev, "failed to allocate memory\n");
 		return -ENOMEM;
 	}
 
-	lpc_driver_data->pdev = pdev;
 
-	lpc_driver_data->bus_info = pdev->dev.platform_data;
+	ast_lpc->pdev = pdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
@@ -336,6 +888,7 @@ static int __devinit ast_lpc_probe(struc
 		goto err_free;
 	}
 
+        printk("res->start = %x, resource_size(res) = %d, pdev->name = %s\n", res->start, resource_size(res), pdev->name);
 	res = request_mem_region(res->start, resource_size(res), pdev->name);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to request memory resource\n");
@@ -343,38 +896,81 @@ static int __devinit ast_lpc_probe(struc
 		goto err_free;
 	}
 
-	lpc_driver_data->reg_base = ioremap(res->start, resource_size(res));
-	if (lpc_driver_data->reg_base == NULL) {
+	ast_lpc->reg_base = ioremap(res->start, resource_size(res));
+	if (ast_lpc->reg_base == NULL) {
 		dev_err(&pdev->dev, "failed to ioremap() registers\n");
 		ret = -ENODEV;
 		goto err_free_mem;
 	}
 
+	ast_lpc->irq = platform_get_irq(pdev, 0);
+	if (ast_lpc->irq < 0) {
+		dev_err(&pdev->dev, "no irq specified\n");
+		ret = -ENOENT;
+		goto err_free_mem;
+	}
+
+	ret = request_irq(ast_lpc->irq, ast_lpc_isr, IRQF_SHARED, "ast-lpc", ast_lpc);
+	if (ret) {
+		printk("AST LPC Unable to get IRQ");
+		goto err_free_mem;
+	}
+#ifdef CONFIG_AST_LPC_MASTER
+	printk("LPC Scan Device... \n");
 #ifdef CONFIG_ARCH_AST1070
-	if(lpc_driver_data->bus_info->bus_scan) {
-		printk("LPC Scan Device... \n");		
-		for(i=0;i<lpc_driver_data->bus_info->scan_node;i++) {
-			ast1070_scu_init(i ,lpc_driver_data->bus_info->bridge_phy_addr + i*0x10000);
-			printk("C%d-[%x] ", i, ast1070_revision_id_info(i));
-			ast1070_vic_init(i, (lpc_driver_data->bus_info->bridge_phy_addr + i*0x10000), IRQ_C0_VIC_CHAIN + i, IRQ_C0_VIC_CHAIN_START + (i*AST_CVIC_NUM));
-			ast1070_scu_dma_init(i);
-			ast1070_uart_dma_init(i, lpc_driver_data->bus_info->bridge_phy_addr);
-			ast_add_device_cuart(i,lpc_driver_data->bus_info->bridge_phy_addr + i*0x10000);
-			ast_add_device_ci2c(i,lpc_driver_data->bus_info->bridge_phy_addr + i*0x10000);
-		}
-		printk("\n");
+	for(i=0;i<ast_lpc->bus_info->scan_node;i++) {
+		ast1070_scu_init(i ,AST_LPC_BRIDGE + i*0x10000);
+		printk("C%d-[%x] ", i, ast1070_revision_id_info(i));
+		ast1070_vic_init(i, (AST_LPC_BRIDGE + i*0x10000), IRQ_C0_VIC_CHAIN + i, IRQ_C0_VIC_CHAIN_START + (i*AST_CVIC_NUM));
+		ast1070_i2c_irq_init(i, (AST_LPC_BRIDGE + i*0x10000), IRQ_C0_VIC_CHAIN + i, IRQ_C0_VIC_CHAIN_START + (i*AST_CVIC_NUM));
+		ast1070_scu_dma_init(i);
+		ast1070_uart_dma_init(i, AST_LPC_BRIDGE);
+		ast_add_device_cuart(i,AST_LPC_BRIDGE + i*0x10000);
+		ast_add_device_ci2c(i,AST_LPC_BRIDGE + i*0x10000);
+	}
+#endif
+	printk("\n");
+	platform_set_drvdata(pdev, ast_lpc);
+#else
+	platform_set_drvdata(pdev, ast_lpc);
+
+	dev_set_drvdata(&pdev->dev, ast_lpc);
+
+#if 0
+	ret = sysfs_create_group(&pdev->dev.kobj, &lpc_attribute_group);
+	if (ret)
+		goto err_free_mem;
 
+	for(i=0; i< 7; i++) {
+		ret = sysfs_create_group(&pdev->dev.kobj, &route_attribute_groups[i]);
+		if (ret)
+			goto err_free_mem;
 	}
-	
+#endif
+#ifdef CONFIG_AST_SNOOP
+	ast_lpc->ast_snoop = kzalloc(sizeof(struct ast_snoop_data) * AST_SNOOP_NUM, GFP_KERNEL);
+#endif
+
+#ifdef CONFIG_AST_SNOOP_DMA
+	ast_lpc->ast_snoop_dma = kzalloc(sizeof(struct ast_snoop_dma_data), GFP_KERNEL);
+#endif
+
+//#ifdef CONFIG_AST_IPMI_KCS
+	ast_lpc->ast_kcs = kzalloc(sizeof(struct ast_kcs_data) * AST_KCS_NUM, GFP_KERNEL);
+//#endif
+
+#ifdef CONFIG_AST_IPMI_BT
+	ast_lpc->ast_bt = kzalloc(sizeof(struct ast_bt_data) * AST_BT_NUM, GFP_KERNEL);
+#endif
+
 #endif
 
-	platform_set_drvdata(pdev, lpc_driver_data);
 	return 0;
 
 err_free_mem:
 	release_mem_region(res->start, resource_size(res));
 err_free:
-	kfree(lpc_driver_data);
+	kfree(ast_lpc);
 
 	return ret;
 }
@@ -400,7 +996,7 @@ static int __devexit ast_lpc_remove(stru
 
 static struct platform_driver ast_lpc_driver = {
 	.driver		= {
-		.name	= "ast_lpc",
+		.name	= "ast-lpc",
 		.owner	= THIS_MODULE,
 	},
 	.probe		= ast_lpc_probe,
Index: new/arch/arm/plat-aspeed/dev-kcs.c
===================================================================
--- new.orig/arch/arm/plat-aspeed/dev-kcs.c
+++ new/arch/arm/plat-aspeed/dev-kcs.c
@@ -45,6 +45,7 @@
 #if defined(CONFIG_AST_KCS) || defined(CONFIG_AST_KCS_MODULE)
 static u64 ast_kcs_dma_mask = 0xffffffffUL;
 
+#if 0
 static struct resource ast_kcs0_resource[] = {
 	[0] = {
 		.start = AST_LPC_BASE,
@@ -57,6 +58,7 @@ static struct resource ast_kcs0_resource
 		.flags = IORESOURCE_IRQ,
 	},
 };
+#endif
 
 static struct platform_device ast_kcs0_device = {
 	.name	= "ast-kcs",
@@ -65,10 +67,11 @@ static struct platform_device ast_kcs0_d
             .dma_mask = &ast_kcs_dma_mask,
             .coherent_dma_mask = 0xffffffff,
     },
-	.resource = ast_kcs0_resource,
-	.num_resources = ARRAY_SIZE(ast_kcs0_resource),
+//	.resource = ast_kcs0_resource,
+//	.num_resources = ARRAY_SIZE(ast_kcs0_resource),
 };
 
+#if 0
 static struct resource ast_kcs1_resource[] = {
 	[0] = {
 		.start = AST_LPC_BASE,
@@ -81,6 +84,7 @@ static struct resource ast_kcs1_resource
 		.flags = IORESOURCE_IRQ,
 	},
 };
+#endif
 
 static struct platform_device ast_kcs1_device = {
 	.name	= "ast-kcs",
@@ -89,10 +93,11 @@ static struct platform_device ast_kcs1_d
             .dma_mask = &ast_kcs_dma_mask,
             .coherent_dma_mask = 0xffffffff,
     },
-	.resource = ast_kcs1_resource,
-	.num_resources = ARRAY_SIZE(ast_kcs1_resource),
+//	.resource = ast_kcs1_resource,
+//	.num_resources = ARRAY_SIZE(ast_kcs1_resource),
 };
 
+#if 0
 static struct resource ast_kcs2_resource[] = {
 	[0] = {
 		.start = AST_LPC_BASE,
@@ -105,6 +110,7 @@ static struct resource ast_kcs2_resource
 		.flags = IORESOURCE_IRQ,
 	},
 };
+#endif
 
 static struct platform_device ast_kcs2_device = {
 	.name	= "ast-kcs",
@@ -113,8 +119,8 @@ static struct platform_device ast_kcs2_d
             .dma_mask = &ast_kcs_dma_mask,
             .coherent_dma_mask = 0xffffffff,
     },
-	.resource = ast_kcs2_resource,
-	.num_resources = ARRAY_SIZE(ast_kcs2_resource),
+//	.resource = ast_kcs2_resource,
+//	.num_resources = ARRAY_SIZE(ast_kcs2_resource),
 };
 
 void __init ast_add_device_kcs(void)
Index: new/arch/arm/plat-aspeed/dev-lpc.c
===================================================================
--- new.orig/arch/arm/plat-aspeed/dev-lpc.c
+++ new/arch/arm/plat-aspeed/dev-lpc.c
@@ -37,11 +37,11 @@ static u32 ast_lpc_base = IO_ADDRESS(AST
 /* --------------------------------------------------------------------
  *  LPC
  * -------------------------------------------------------------------- */
-#if defined(CONFIG_LPC) || defined(CONFIG_LPC_MODULE)
+//#if defined(CONFIG_LPC) || defined(CONFIG_LPC_MODULE)
 static struct resource ast_lpc_resource[] = {
 	[0] = {
 		.start = AST_LPC_BASE,
-		.end = AST_LPC_BASE + SZ_4K,
+		.end = AST_LPC_BASE + SZ_512 - 1,
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -54,7 +54,7 @@ static struct resource ast_lpc_resource[
 static u64 ast_lpc_dma_mask = 0xffffffffUL;
 
 static struct platform_device ast_lpc_device = {
-	.name	= "ast_lpc",
+	.name	= "ast-lpc",
     .id = 0,
     .dev = {
             .dma_mask = &ast_lpc_dma_mask,
@@ -73,7 +73,7 @@ static struct resource ast_lpc_plus_reso
 };
 
 static struct platform_device ast_lpc_plus_device = {
-	.name	= "ast_lpc_plus",
+	.name	= "ast-lpc_plus",
     .id = 1,
     .dev = {
             .dma_mask = &ast_lpc_dma_mask,
@@ -90,14 +90,18 @@ void __init ast_add_device_lpc(void)
 
 	platform_device_register(&ast_lpc_device);
 	platform_device_register(&ast_lpc_plus_device);
-}
-#else
-void __init ast_add_device_lpc(void) {
-  // Since we disable LPC, bring the UART1 and UART2 out from LPC control
-  writel((readl(ast_lpc_base + AST_LPC_HICR9)
+        writel((readl(ast_lpc_base + AST_LPC_HICR9)
 	  & ~(LPC_HICR9_SOURCE_UART1|LPC_HICR9_SOURCE_UART2
 	      |LPC_HICR9_SOURCE_UART3|LPC_HICR9_SOURCE_UART4)),
 	 ast_lpc_base + AST_LPC_HICR9);
 }
-#endif
+//#else
+//void __init ast_add_device_lpc(void) {
+  // Since we disable LPC, bring the UART1 and UART2 out from LPC control
+//  writel((readl(ast_lpc_base + AST_LPC_HICR9)
+//	  & ~(LPC_HICR9_SOURCE_UART1|LPC_HICR9_SOURCE_UART2
+//	      |LPC_HICR9_SOURCE_UART3|LPC_HICR9_SOURCE_UART4)),
+//	 ast_lpc_base + AST_LPC_HICR9);
+//}
+//#endif
 
Index: new/arch/arm/plat-aspeed/include/plat/ast-lpc.h
===================================================================
--- new.orig/arch/arm/plat-aspeed/include/plat/ast-lpc.h
+++ new/arch/arm/plat-aspeed/include/plat/ast-lpc.h
@@ -12,12 +12,77 @@
  * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/interrupt.h>
+
+/************************  IPMI  ******************************************/
+#define AST_IPMI_PKT_SIZE               (512)
+#define AST_KCS_NUM       3
+typedef void (*ast_ipmi_irq)(void *data);
+
+#define AST_IPMI_KCS0_REGSPACINGS                       4       //any
+#define AST_IPMI_KCS1_REGSPACINGS                       4       //any
+#define AST_IPMI_KCS2_REGSPACINGS                       1       //fix
+#define AST_IPMI_KCS3_REGSPACINGS                       1       //any
+
+enum kcs_states {
+	KCS_PHASE_IDLE = 0,
+	KCS_PHASE_WRITE,
+	KCS_PHASE_WRITE_END,
+	KCS_PHASE_READ,
+	KCS_PHASE_ERROR,
+	KCS_PHASE_ERROR1,
+	KCS_PHASE_ERROR2,
+	/* The hardware failed to follow the state machine. */
+	KCS_PHASE_HOSED
+};
+
+struct ast_kcs_data {
+	//driver information
+	struct platform_device *pdev;
+	int 			open_count;
+	struct miscdevice	miscdev;
+	u8				kcs_reg;				/* register info */
+	struct ast_lpc_data	*ast_lpc;
+
+	//-> phase state
+	enum kcs_states		KCSPhase;
+	u8  KCSError;
+	//RX
+	u32	KCSRcvPktIx;
+	u8	*pKCSRcvPkt;
+	u8 	KCSPktRdy;
+	//Tx
+	u8 	KCSSendWait;
+	u16	KCSSendPktIx;
+	u16	KCSSendPktLen;
+	u8	*pKCSSendPkt;
+	//register offset -- >
+	void __iomem			*str;
+	void __iomem			*idr;
+	void __iomem			*odr;
+	u8	regspacings;
+	/* cdriver callbacks */
+	ast_ipmi_irq	 kcs_irq_hander;	/* buffer done callback */
+};
+
+struct ast_lpc_data {
+	struct platform_device *pdev;
+	void __iomem			*reg_base;			/* virtual */
+	int 					irq;					//LPC IRQ number
+	//Slave mode
+	struct ast_snoop_data 			*ast_snoop;
+	struct ast_snoop_dma_data 	*ast_snoop_dma;
+	struct ast_kcs_data 			*ast_kcs;
+	struct ast_bt_data 			*ast_bt;
+};
 
 struct ast_lpc_bus_info
 {
-	u8 lpc_dev_mode; /* 0: host mode , 1: dev mode*/	
-	u8 bus_scan;
-	u8 scan_node;	
+	u8 lpc_dev_mode; /* 0: host mode , 1: dev mode*/
+        u8 bus_scan;
+	u8 scan_node;
 	u8 lpc_mode; /* 0: lpc , 1: lpc+ */
 	u32 bridge_phy_addr;
 };
@@ -25,10 +90,24 @@ struct ast_lpc_bus_info
 struct ast_lpc_driver_data
 {
 	struct platform_device *pdev;
-	void __iomem		*reg_base;			/* virtual */	
-	int 				irq;				//I2C IRQ number 
-	u32					bus_id;				//for i2c dev# IRQ number check 
+	void __iomem		*reg_base;			/* virtual */
+	int 				irq;				//I2C IRQ number
+	u32					bus_id;				//for i2c dev# IRQ number check
 	struct ast_lpc_bus_info *bus_info;
 };
 
+/************************  LPC API ***********************************************/
+
+/* common function */
+extern u32 StrToHex(char *p);
+
+/******************************** IPMI KCS API ************************************/
+extern struct ast_kcs_data *register_ipmi_kcs_drv(u8 kcs_no);
+extern void request_ipmi_kcs_irq(u8 kcs_no, ast_ipmi_irq handler);
+
+extern u16 ast_get_ipmi_kcs_addr(struct ast_lpc_data *ast_lpc, u8 kcs_ch);
+extern void ast_set_ipmi_kcs_addr(struct ast_lpc_data *ast_lpc, u8 kcs_ch, u16 kcs_addr);
+extern u8 ast_get_ipmi_kcs_en(struct ast_lpc_data *ast_lpc, u8 kcs_ch);
+extern void ast_set_ipmi_kcs_en(struct ast_lpc_data *ast_lpc, u8 kcs_ch, u8 enable);
 extern struct ast_lpc_info *ast_get_lpc_info(void);
+
Index: new/drivers/char/aspeed/ast_kcs.c
===================================================================
--- /dev/null
+++ new/drivers/char/aspeed/ast_kcs.c
@@ -0,0 +1,644 @@
+/********************************************************************************
+* File Name     : ast_kcs.c
+* Author         : Ryan Chen
+* Description   : AST IPMI KCS
+*
+* Copyright (C) 2012-2020  ASPEED Technology Inc.
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*   Version      : 1.0
+*   History      :
+*      1. 2016/01/30 Ryan Chen create this file
+*
+# Linux x86 host
+# modprobe ipmi_si type=kcs ports=0xca2 regspacings=1
+# modprobe ipmi_si type=kcs ports=0xca8 regspacings=4
+# x86 KCS Port : CA2/CA3, CB2/CB3, CA0/CA4, CA8/CAC
+# Set KCS default address : KCS0 : CA0/CA4, KCS1 : CA8/CAC, KCS3 : CA2/CA3, KCS4 : CB2/CB3
+
+*test in Dos [Notice : ipmitool only use fix in ca2/ca3 ]
+# IPMITOOL 20 18 01
+********************************************************************************/
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <plat/ast-lpc.h>
+
+//#define CONFIG_KCS_DEBUG
+
+#ifdef CONFIG_KCS_DEBUG
+#define KCS_DBG(fmt, args...) printk(KERN_DEBUG "%s() " fmt,__FUNCTION__, ## args)
+#else
+#define KCS_DBG(fmt, args...)
+#endif
+
+struct kcs_parameter {
+	u8	ch_enable;
+	u8	ch_type;
+};
+
+
+#define KCS_CMD_DAT	0x8
+#define KCS_IBF 			0x2
+#define KCS_OBF			0x1
+////////////////////////////////////////////
+/* KCS Command Control codes. */
+#define KCS_GET_STATUS_ABORT	0x60
+#define KCS_WRITE_START			0x61
+#define KCS_WRITE_END			0x62
+#define KCS_READ_BYTE			0x68
+
+/* Status bits. */
+#define IPMI_KCS_IDLE_STATE		(0 << 6)
+#define IPMI_KCS_READ_STATE	(1 << 6)
+#define IPMI_KCS_WRITE_STATE	(2 << 6)
+#define IPMI_KCS_ERROR_STATE	(3 << 6)
+
+
+#define GET_STATUS_STATE(status) (((status) >> 6) & 0x03)
+#define GET_STATUS_ATN(status) ((status) & 0x04)
+#define GET_STATUS_IBF(status) ((status) & 0x02)
+#define GET_STATUS_OBF(status) ((status) & 0x01)
+
+/* KCS Error Codes */
+#define KCS_NO_ERROR			0x00
+#define KCS_ABORTED_BY_COMMAND		0x01
+#define KCS_ILLEGAL_CONTROL_CODE	0x02
+#define KCS_LENGTH_ERROR		0x06
+#define KCS_UNSPECIFIED_ERROR		0xff
+
+
+////////////////////////////////////////////////////////////////
+//read id
+u8 sbuf[18] = {0x1c, 0x01, 0x00, 0x20, 0x01, 0x01, 0x01, 0x02,
+                 0xBF, 0x00, 0x00, 0x00, 0xBB, 0xAA, 0x00, 0x00,
+                 0x00, 0x00};
+
+
+
+/************************  IPMI KCS  ****************************************************************/
+static inline unsigned char read_kcs_status(struct ast_kcs_data *ast_kcs)
+{
+	return readl(ast_kcs->str);
+}
+
+static inline unsigned char read_kcs_data(struct ast_kcs_data *ast_kcs)
+{
+	return readl(ast_kcs->idr);
+}
+
+static inline unsigned char read_kcs_cmd(struct ast_kcs_data *ast_kcs)
+{
+	return readl(ast_kcs->idr);
+}
+
+static inline void write_kcs_data(struct ast_kcs_data *ast_kcs, unsigned char data)
+{
+	writel(data, ast_kcs->odr);
+}
+
+static inline void write_kcs_status(struct ast_kcs_data *ast_kcs, unsigned char str)
+{
+	u32 sts = readl(ast_kcs->str) & (~0xC0);
+	writel( sts | str, ast_kcs->str);
+}
+
+/**************************   LPC  KCS SYSFS  **********************************************************/
+static ssize_t
+store_ipmi_kcs_sms_atn(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	input_val = simple_strtoul(sysfsbuf, NULL, 10);
+	if(input_val)
+		writel(readl(ast_kcs->str) | (0x1 << 2), ast_kcs->str);
+	else
+		writel(readl(ast_kcs->str) & ~(0x1 << 2), ast_kcs->str);
+	return count;
+}
+
+static ssize_t
+show_ipmi_kcs_sms_atn(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	return sprintf(sysfsbuf, "%d\n", (readl(ast_kcs->str) & 0x4) >> 2);
+}
+static DEVICE_ATTR(sms_atn, S_IRUGO | S_IWUSR, show_ipmi_kcs_sms_atn, store_ipmi_kcs_sms_atn);
+
+static ssize_t
+store_ipmi_kcs_oem(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	input_val = simple_strtoul(sysfsbuf, NULL, 10);
+	input_val &= 0x3;
+	writel((readl(ast_kcs->str) & 0xcf) | (input_val << 4), ast_kcs->str);
+	return count;
+}
+
+static ssize_t
+show_ipmi_kcs_oem(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	return sprintf(sysfsbuf, "%x\n", (readl(ast_kcs->str) & 0xcf) >> 4);
+}
+static DEVICE_ATTR(oem, S_IRUGO | S_IWUSR, show_ipmi_kcs_oem, store_ipmi_kcs_oem);
+
+static ssize_t
+store_ipmi_kcs_str(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	input_val = StrToHex(sysfsbuf);
+	writel(input_val, ast_kcs->str);
+	return count;
+}
+
+static ssize_t
+show_ipmi_kcs_str(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	return sprintf(sysfsbuf, "%x\n", readl(ast_kcs->str));
+}
+static DEVICE_ATTR(str, S_IRUGO | S_IWUSR, show_ipmi_kcs_str, store_ipmi_kcs_str);
+
+static ssize_t
+store_ipmi_kcs_addr(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	input_val = StrToHex(sysfsbuf);
+	ast_set_ipmi_kcs_addr(ast_kcs->ast_lpc, ast_kcs->pdev->id, input_val);
+	return count;
+}
+
+static ssize_t
+show_ipmi_kcs_addr(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	return sprintf(sysfsbuf, "%x\n", ast_get_ipmi_kcs_addr(ast_kcs->ast_lpc, ast_kcs->pdev->id));
+}
+static DEVICE_ATTR(addr, S_IRUGO | S_IWUSR, show_ipmi_kcs_addr, store_ipmi_kcs_addr);
+
+static ssize_t
+store_ipmi_kcs_en(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	u32 input_val;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	input_val = simple_strtoul(sysfsbuf, NULL, 10);
+	ast_set_ipmi_kcs_en(ast_kcs->ast_lpc, ast_kcs->pdev->id, input_val);
+	return count;
+}
+
+static ssize_t
+show_ipmi_kcs_en(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+{
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(dev);
+	return sprintf(sysfsbuf, "%d : %s\n", ast_get_ipmi_kcs_en(ast_kcs->ast_lpc, ast_kcs->pdev->id),ast_get_ipmi_kcs_en(ast_kcs->ast_lpc, ast_kcs->pdev->id) ? "Enable":"Disable");
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, show_ipmi_kcs_en, store_ipmi_kcs_en);
+
+
+static struct attribute *ast_ipmi_kcs_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_addr.attr,
+	&dev_attr_str.attr,
+	&dev_attr_sms_atn.attr,
+	&dev_attr_oem.attr,
+//	&dev_attr_buff.attr,
+	NULL
+};
+
+static const struct attribute_group ipmi_kcs_attribute_group = {
+	.attrs = ast_ipmi_kcs_attributes,
+//	.is_visible = ast_ipmi_kcs_attrs_visible,
+};
+
+/***********************************************************************/
+
+static int ast_kcs_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *c = file->private_data;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(c->this_device);
+
+	KCS_DBG("ast_kcs_open\n");
+
+	/* Flush input queue on first open */
+	if (ast_kcs->open_count)
+		return -1;
+
+	ast_kcs->open_count++;
+	return 0;
+}
+
+static int ast_kcs_release(struct inode *inode, struct file *file)
+{
+	struct miscdevice *c = file->private_data;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(c->this_device);
+
+	KCS_DBG("ast_kcs_release\n");
+	ast_kcs->open_count--;
+
+	return 0;
+}
+
+static ssize_t ast_kcs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+{
+	struct miscdevice *c = file->private_data;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(c->this_device);
+
+
+	if(ast_kcs->KCSPktRdy) {
+		if(copy_to_user(buf, ast_kcs->pKCSRcvPkt, ast_kcs->KCSRcvPktIx)) {
+			dev_err(&(ast_kcs->pdev->dev), "read fail \n");
+			return -EINVAL;
+		}
+		ast_kcs->KCSSendWait = 1;
+		ast_kcs->KCSPktRdy = 0;
+		return ast_kcs->KCSRcvPktIx;
+	} else {
+		return 0;
+	}
+}
+
+ssize_t ast_kcs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
+{
+	struct miscdevice *c = file->private_data;
+	struct ast_kcs_data *ast_kcs = dev_get_drvdata(c->this_device);
+
+	if (count > AST_IPMI_PKT_SIZE) {
+		dev_err(&(ast_kcs->pdev->dev), "write too long, len = %d\n", (int)count);
+		return -EINVAL;
+	}
+
+	if(ast_kcs->KCSSendWait) {
+		KCS_DBG("count %d \n", count);
+		if(count) {
+			if(copy_from_user(ast_kcs->pKCSSendPkt, buf, count)) {
+				dev_err(&(ast_kcs->pdev->dev), "copy fail = %d, \n", (int)count);
+				return -EINVAL;
+			}
+			ast_kcs->KCSSendWait = 0;
+			/* Send the first byte */
+			ast_kcs->KCSSendPktIx = 0;
+			ast_kcs->KCSSendPktLen = count;
+			KCS_DBG("send idx %d : %x \n",ast_kcs->KCSSendPktIx, ast_kcs->pKCSSendPkt[ast_kcs->KCSSendPktIx]);
+			if(ast_kcs->KCSPhase == KCS_PHASE_READ) {
+				ast_kcs->KCSSendPktIx++;
+        write_kcs_data(ast_kcs, ast_kcs->pKCSSendPkt[0]);
+			} else {
+				printk("KCS resp error \n");
+				return -EINVAL;
+			}
+		} else {
+			ast_kcs->KCSError = KCS_UNSPECIFIED_ERROR;
+			ast_kcs->KCSSendWait = 0;
+			/* Send the first byte */
+			ast_kcs->KCSSendPktIx = 0;
+			ast_kcs->KCSSendPktLen = 0;
+			write_kcs_status(ast_kcs, IPMI_KCS_ERROR_STATE);
+		}
+
+		return count;
+	} else {
+		return -EINVAL;
+	}
+
+}
+
+static const struct file_operations ast_kcs_fops = {
+	.owner 			=	THIS_MODULE,
+	.llseek 			=	no_llseek,
+	.read 			= 	ast_kcs_read,
+	.write 			= 	ast_kcs_write,
+	.open 			=	ast_kcs_open,
+	.release 		=	ast_kcs_release,
+};
+
+
+/***********************************************************************/
+static void ast_ipmi_kcs_rx(struct ast_kcs_data *ast_kcs)
+{
+	u8 b;
+	int i;
+	switch (ast_kcs->KCSPhase) {
+		case KCS_PHASE_WRITE:
+			KCS_DBG("KCS_PHASE_WRITE \n");
+			/* Set the state to write state */
+			write_kcs_status(ast_kcs, IPMI_KCS_WRITE_STATE);
+			/* Read the BYTE from the data register */
+			ast_kcs->pKCSRcvPkt[ast_kcs->KCSRcvPktIx] = read_kcs_data(ast_kcs);
+			KCS_DBG("rx data = [%x] \n", ast_kcs->pKCSRcvPkt[ast_kcs->KCSRcvPktIx]);
+			ast_kcs->KCSRcvPktIx++;
+			if(ast_kcs->KCSRcvPktIx > 272) {
+				printk("ERROR ---> TODO ... \n");
+				ast_kcs->KCSRcvPktIx--;
+			}
+			break;
+
+		case KCS_PHASE_WRITE_END :
+			KCS_DBG("KCS_PHASE_WRITE_END \n");
+			/* Set the state to READ_STATE */
+			write_kcs_status(ast_kcs, IPMI_KCS_READ_STATE);
+			/* Read the BYTE from the data register */
+			ast_kcs->pKCSRcvPkt[ast_kcs->KCSRcvPktIx] = read_kcs_data(ast_kcs);
+			KCS_DBG("rx data = [%x] \n", ast_kcs->pKCSRcvPkt[ast_kcs->KCSRcvPktIx]);
+			ast_kcs->KCSRcvPktIx++;
+
+			/* Move to READ Phase */
+			ast_kcs->KCSPhase = KCS_PHASE_READ;
+			/* Signal receive data ready */
+			ast_kcs->KCSPktRdy = 1;
+#if 0
+			printk(KERN_DEBUG "Total Rx Data : [");
+			for(i=0; i < ast_kcs->KCSRcvPktIx; i++)
+				printk(KERN_DEBUG " %x", ast_kcs->pKCSRcvPkt[i]);
+			printk(KERN_DEBUG "] \n");
+#endif
+			//trigger timeout --> TODO ~~~~
+			break;
+		case KCS_PHASE_READ:
+			KCS_DBG("KCS_PHASE_READ \n");
+
+			/* If we have reached the end of the packet move to idle state */
+			if (ast_kcs->KCSSendPktIx == ast_kcs->KCSSendPktLen)
+				write_kcs_status(ast_kcs, IPMI_KCS_IDLE_STATE);
+
+			/* Read the byte returned by the SMS */
+			b = read_kcs_cmd(ast_kcs);
+			//SA Need to clear IBF
+			//sa_0111 CLEAR_IBF_STATUS(ChannelNum);
+
+			if (b != KCS_READ_BYTE)
+			{
+				KCS_DBG("KCS_PHASE_READ : Set Error State TODO ~~~\n");
+				write_kcs_status(ast_kcs, IPMI_KCS_READ_STATE);
+				write_kcs_data(ast_kcs, 0);
+				//SA Set OBF Byte
+				break;
+			}
+
+			/* If we are finished transmitting, send the dummy byte */
+			if (ast_kcs->KCSSendPktIx == ast_kcs->KCSSendPktLen)
+			{
+				KCS_DBG("KCS_PHASE_READ : finished transmitting\n");
+				ast_kcs->KCSPhase = KCS_PHASE_IDLE;
+				write_kcs_data(ast_kcs, 0);
+				//SA Set OBF Byte
+
+				/* Set Transmission Complete */
+				break;
+			}
+			/* Transmit the next byte from the send buffer */
+			KCS_DBG("send idx %d : %x \n",ast_kcs->KCSSendPktIx, ast_kcs->pKCSSendPkt[ast_kcs->KCSSendPktIx]);
+			write_kcs_data(ast_kcs, ast_kcs->pKCSSendPkt[ast_kcs->KCSSendPktIx]);
+			ast_kcs->KCSSendPktIx++;
+
+			break;
+
+		case KCS_PHASE_ERROR1:
+			KCS_DBG("KCS_PHASE_ERROR1 \n");
+			/* Set the KCS State to READ_STATE */
+			write_kcs_status(ast_kcs, IPMI_KCS_READ_STATE);
+			/* Read the Dummy byte  */
+			read_kcs_data(ast_kcs);
+			/* Write the error code to Data out register */
+			write_kcs_data(ast_kcs, ast_kcs->KCSError);
+			/* Set to default error */
+			ast_kcs->KCSError = KCS_ABORTED_BY_COMMAND;
+
+			//SA Set OBF Byte
+
+			/* Set the abort phase to be error2 */
+			ast_kcs->KCSPhase = KCS_PHASE_ERROR2;
+	//		pKCSBuf->AbortPhase = ABORT_PHASE_ERROR2;
+			break;
+		case KCS_PHASE_ERROR2:
+			KCS_DBG("ABORT_PHASE_ERROR2 \n");
+			/**  * The system software has read the error code. Go to idle  * state. 	**/
+			write_kcs_status(ast_kcs, IPMI_KCS_IDLE_STATE);
+
+			/* Read the Dummy byte  */
+			read_kcs_data(ast_kcs);
+
+			ast_kcs->KCSPhase = KCS_PHASE_IDLE;
+	//		pKCSBuf->AbortPhase = 0;
+			/* Send the dummy byte  */
+			write_kcs_data(ast_kcs, 0);
+			break;
+		default:
+			KCS_DBG("rx default == > TODO .. \n");
+			/* Read the Dummy byte  */
+			read_kcs_data(ast_kcs);
+			break;
+	}
+}
+
+static void ast_ipmi_kcs_cmd_dat(struct ast_kcs_data *ast_kcs)
+{
+	u8 cmd;
+
+	/* Set the status to WRITE_STATE */
+	write_kcs_status(ast_kcs, IPMI_KCS_WRITE_STATE);
+
+	/* Read the command */
+	cmd = read_kcs_cmd(ast_kcs);
+
+	if (cmd == KCS_GET_STATUS_ABORT) {
+		/* Keep the status to WRITE_STATE */
+		/* Set the abort phase to be error1 */
+		ast_kcs->KCSPhase = KCS_PHASE_ERROR1;
+		ast_kcs->KCSPktRdy = 0;
+		ast_kcs->KCSSendWait = 0;
+		/* Send the dummy byte  */
+		write_kcs_data(ast_kcs, 0);
+		return;
+	}
+
+	if((ast_kcs->KCSPhase != KCS_PHASE_IDLE) && (ast_kcs->KCSPhase != KCS_PHASE_WRITE)) {
+		/* Set the error code if cmd when phase read, keep it if phase errors*/
+		if(ast_kcs->KCSPhase == KCS_PHASE_READ)
+			ast_kcs->KCSError = KCS_ILLEGAL_CONTROL_CODE;
+		ast_kcs->KCSPhase = KCS_PHASE_ERROR;
+		ast_kcs->KCSPktRdy = 0;
+		ast_kcs->KCSSendWait = 0;
+		write_kcs_status(ast_kcs, IPMI_KCS_ERROR_STATE);
+//		printk("Err STAT %d, cmd %x \n", ast_kcs->KCSPhase, cmd);
+		return;
+	}
+
+	switch (cmd) {
+		case KCS_WRITE_START:
+			KCS_DBG("KCS_WRITE_START \n");
+			/* Set the Index to 0 */
+			ast_kcs->KCSRcvPktIx = 0;
+			/* Set the phase to WRITE */
+			ast_kcs->KCSPhase = KCS_PHASE_WRITE;
+			break;
+		case KCS_WRITE_END:
+			/* Set the phase to write end */
+			KCS_DBG("KCS_WRITE_END \n");
+			ast_kcs->KCSPhase = KCS_PHASE_WRITE_END;
+//			mod_timer(&ast_kcs->kcs_timer, jiffies + 5 * HZ);
+			break;
+		default:
+			KCS_DBG("undefine cmd %x \n", cmd);
+			/* Invalid command code - Set an error state */
+			ast_kcs->KCSError = KCS_ILLEGAL_CONTROL_CODE;
+			/* Set the phase to error phase */
+			ast_kcs->KCSPhase = KCS_PHASE_ERROR;
+			ast_kcs->KCSPktRdy = 0;
+			ast_kcs->KCSSendWait = 0;
+			write_kcs_status(ast_kcs, IPMI_KCS_ERROR_STATE);
+			break;
+	}
+}
+
+static void ast_ipmi_kcs_handle(void *data)
+{
+	struct ast_kcs_data *ast_kcs = (struct ast_kcs_data *)data;
+	u32 str= read_kcs_status(ast_kcs) & (KCS_CMD_DAT | KCS_IBF);
+	switch(str) {
+		case (KCS_CMD_DAT | KCS_IBF):
+			KCS_DBG("%d-LPC_STR_CMD_DAT | LPC_STR_IBF \n", ast_kcs->pdev->id);
+			ast_ipmi_kcs_cmd_dat(ast_kcs);
+			break;
+		case KCS_IBF:
+			KCS_DBG("%d-LPC_STR_IBF \n", ast_kcs->pdev->id);
+//			mod_timer(&ast_kcs->kcs_timer, jiffies + 5 * HZ);
+			ast_ipmi_kcs_rx(ast_kcs);
+			break;
+		default:
+			printk("%d-ERROR TODO \n", ast_kcs->pdev->id);
+			break;
+	}
+}
+/***********************************************************************/
+static void ast_kcs_timeout(unsigned long data)
+{
+	struct ast_kcs_data *ast_kcs = (struct ast_kcs_data *) data;
+	printk("kcs_timout \n");
+	ast_kcs->KCSError = KCS_UNSPECIFIED_ERROR;
+	ast_kcs->KCSPhase = KCS_PHASE_ERROR;
+	ast_kcs->KCSPktRdy = 0;
+	ast_kcs->KCSSendWait = 0;
+	write_kcs_status(ast_kcs, IPMI_KCS_ERROR_STATE);
+
+}
+
+static int ast_kcs_probe(struct platform_device *pdev)
+{
+	int ret=0;
+	char kcs_name[10];
+	struct ast_kcs_data *ast_kcs = register_ipmi_kcs_drv(pdev->id);
+
+   KCS_DBG("ast_kcs_probe\n");
+
+	ast_kcs->pKCSRcvPkt = kmalloc(AST_IPMI_PKT_SIZE * 2, GFP_KERNEL);
+	ast_kcs->KCSRcvPktIx = 0;
+	ast_kcs->KCSPktRdy = 0;
+	ast_kcs->pKCSSendPkt = ast_kcs->pKCSRcvPkt + AST_IPMI_PKT_SIZE;
+	ast_kcs->KCSPhase = KCS_PHASE_IDLE;
+	ast_kcs->KCSError = KCS_ABORTED_BY_COMMAND;
+
+#if 0
+	init_timer(&(ast_kcs->kcs_timer));
+//	ast_kcs->kcs_timer.data = (unsigned long) ast_kcs;
+//	ast_kcs->kcs_timer.function = ast_kcs_timeout;
+//	ast_kcs->kcs_timer.expires = jiffies + 5 * HZ;	//5 second
+#endif
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &ipmi_kcs_attribute_group);
+	if (ret)
+		goto err_free_mem;
+
+	ast_kcs->pdev = pdev;
+	ast_kcs->miscdev.minor = MISC_DYNAMIC_MINOR;
+
+	snprintf(kcs_name, sizeof(kcs_name), "ast-kcs.%d", pdev->id);
+
+	ast_kcs->miscdev.fops = &ast_kcs_fops;
+	ast_kcs->miscdev.parent = &pdev->dev;
+	ast_kcs->miscdev.name = kcs_name;
+	ret = misc_register(&ast_kcs->miscdev);
+	if (ret){
+		printk(KERN_ERR "KCS : failed to request interrupt\n");
+		goto err_free_mem;
+	}
+
+	request_ipmi_kcs_irq(pdev->id, ast_ipmi_kcs_handle);
+
+	platform_set_drvdata(pdev, ast_kcs);
+
+	dev_set_drvdata(ast_kcs->miscdev.this_device, ast_kcs);
+
+	printk(KERN_INFO "ast_kcs.%d: driver successfully loaded.\n",pdev->id);
+
+	return 0;
+
+
+err_free_mem:
+	kfree(ast_kcs->pKCSRcvPkt);
+
+	printk(KERN_WARNING "ast_kcs: driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+static int ast_kcs_remove(struct platform_device *pdev)
+{
+	struct ast_kcs_data *ast_kcs = platform_get_drvdata(pdev);
+	KCS_DBG("ast_kcs_remove\n");
+	misc_deregister(&ast_kcs->miscdev);
+	ast_kcs->kcs_reg = 0;
+	kfree(ast_kcs->pKCSRcvPkt);
+
+	return 0;
+}
+
+static struct platform_driver ast_kcs_driver = {
+        .probe                  = ast_kcs_probe,
+        .remove                 = __devexit_p(ast_kcs_remove),
+
+//	.remove 		= ast_kcs_remove,
+	.driver         = {
+		.name   = "ast-kcs",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init
+ast_kcs_init(void)
+{
+        return platform_driver_register(&ast_kcs_driver);
+}
+
+static void __exit
+ast_kcs_exit(void)
+{
+        platform_driver_unregister(&ast_kcs_driver);
+}
+
+module_init(ast_kcs_init);
+module_exit(ast_kcs_exit);
+
+//module_platform_driver_probe(ast_kcs_driver, ast_kcs_probe);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("AST KCS driver");
+MODULE_LICENSE("GPL");
+
Index: new/drivers/char/misc.c
===================================================================
--- new.orig/drivers/char/misc.c
+++ new/drivers/char/misc.c
@@ -118,17 +118,17 @@ static int misc_open(struct inode * inod
 	struct miscdevice *c;
 	int err = -ENODEV;
 	const struct file_operations *old_fops, *new_fops = NULL;
-	
+
 	lock_kernel();
 	mutex_lock(&misc_mtx);
-	
+
 	list_for_each_entry(c, &misc_list, list) {
 		if (c->minor == minor) {
-			new_fops = fops_get(c->fops);		
+			new_fops = fops_get(c->fops);
 			break;
 		}
 	}
-		
+
 	if (!new_fops) {
 		mutex_unlock(&misc_mtx);
 		request_module("char-major-%d-%d", MISC_MAJOR, minor);
@@ -144,6 +144,13 @@ static int misc_open(struct inode * inod
 			goto fail;
 	}
 
+	/*
+	 * Place the miscdevice in the file's
+	 * private_data so it can be used by the
+	 * file operations, including f_op->open below
+	 */
+	file->private_data = c;
+
 	err = 0;
 	old_fops = file->f_op;
 	file->f_op = new_fops;
